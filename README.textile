h1. Rack Auth

A gem that provides authentication to an arbitrary rack application.

This is still very experimental and incomplete in some pretty fundamental ways so please don't assume this is safe to use in a production application yet.  It does however represent the concept.

Based heavily on merb-auth this library acts as middleware in a rack application and operates at a fairly low level.  It is intended that interfaces will be built to make sugary api's inside applications/frameworks.

h2. Concepts

The system acts as middleware, must be in the Rack stack after session middleware (require env['rack.session']).

rack-auth, like merb-auth doesn't require any specific logic for authentication and instead, provides a 
mechanism that allows for custom logic to be used.

One style of authenticating is referred to as a Strategy.  You can have multiple strategies and each will be attempted until either one is successful or all fail.  If one is halted, or all fail, you should throw an :unauthenticated symbol.

When a failure occurs, the result is generated by a rack application that you specify when configuring the stack as the :failure_app.  This is where you would render any login forms etc that you may need  e.g.

<code>
  fail_app = lambda{|e| [401, {"Content-Type" => "text/plain"}, ["Fail App"]]}
  
  @app = Rack::Builder.new do
    use Rack::Session::Cookie, :secret => "Foo"
    use Rack::Auth::Manager, :failure_app => fail_app
    run lambda { |env| [200, {'Content-Type' => 'text/plain'}, 'OK'] }
  end
  
</code>

You can also use the @:default@ option to specify an array of strategies to try by default

h2. Strategies

A strategy is a descendant of Rack::Auth::Strategies::Base and should implement an @authenticate!@ method.

You declare a strategy like this:

<code>
  Rack::Auth::Strategies.add(:label) do
    def authenticate!
      # stuff in here for authentication
    end
  end
</code>
And use it like
<code>
  env['rack.auth'].authenticated?(:label)
</code>

The strategy is a class so you can mixin any logic you need to.

Inside a strategy there are a number of methods available to control what happens:

* @pass@ - ignore this strategy
* @success(user_object)@ - flags the strategy as successful, and stores the user_object into the session
* @fail!(message)@ - flags the strategy as a failure with a message
* @redirect!(url, params = {}, opts = {})@ - halts and sets up information to perform a redirect.  Does not actually perform the redirect.  
* @custom!(rack_array)@ - halts and sets up a custom rack array to return
* @headers(hash_to_merge)@ - access to the headers that will be returned by the strategy
* @self.status=@ - set the status for a return directly
* @message=@ - set the response message directly
* @halt!@ - halt the cascading of strategies.  This will mean that this strategy will be treated as containing any information required.

An example of a password / username strategy may look like this

<code>
  Rack::Auth::Strategies.add(:password) do
    def authenticate!
      return pass unless params[:username] || params[:password]
      u = User.authenticate(params[:username], params[:password])
      u.nil? ? fail!("Could Not Login") : success(u)
    end
  end
</code>


h2. Checking for authentication

rack-auth injects a lazy object into the env.  If you don't use it it doesn't do anything.  You can ask it if a request is authenticated, or, ask it to insist that a request be authenticated.

Asking for authentication:
<code>
  stuff if env['rack.auth'].authenticated?(:strategy1, :strategy2)
</code>

Insisting on authentication
<code>
  env['rack.auth'].authenticate!(:strategy1, :strategy2)
</code>

When you insist on authentication, if no strategy is found to authenticate, an :unauthenticated symbol is thrown.  This causes the failure app (login form) to be called.

h2. Sessions

Any kind of object can be used as an authenticated object in rack-auth.  This of course means that you need to tell rack-auth how to serialize the objects that you're storing as "user" objects in and out of the session.

Here's how to do that:

<code>
  class Rack::Auth::Manager
    def user_session_key(user)
      case user
      when ActiveRecord
        user.id
      when nil
        nil
      else
        raise "Unknown User Type"
      end
    end
  end
</code>

You'll also need to tell rack-auth how to get the user out of the session:

<code>
  class Rack::Auth::Manager
    def user_from_session(key)
      return nil if key.nil?
      User.find(:first, :id => key)
    end
  end
</code>

h2. Scopes

You can have multiple logins in a single session with rack-auth by using scopes.  The default scope is :default

<code>
  # getting scoped users
  env['rack.auth'].user #=> default user
  env['rack.auth'].user(:sudo) #=> :sudo user
  
  # setting scoped users
  env['rack.auth'].authenticate!(:password, :basic, :scope => :sudo)
  env['rack.auth'].set_user(@user, :scope => :secure)
</code>

h2. Errors

rack-auth provides an error system that works with helpers like @error_messages_for@.  You can set an error at any time during an authenticated request:

<code>
  Rack::Auth::Strategies.add(:foo) do
    def authenticate!
      # oops
      errors.add(:login, "That login didn't work foo!")
    end
  end
  
  # In your merb helper
  error_messages_for env['rack.auth']
  
  # In your specs
  env['rack.auth'].errors.on(:login).should == ["That login didn't work foo!"] 
</code>

h2. Prolly is more to mention

But I can't think of it right now.